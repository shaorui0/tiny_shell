# 背景

## 为什么要做这个项目？

『思维敏捷，做事细致，喜欢立刻动手，擅长查找资料，爱追根究底，能复盘反省，多总结反思，能解决问题，愿交流分享，可尽职尽责。』

做出像这样小而美的项目有很多优点，如果其中有你想达到的目标，不妨跟着做一下：

#### 应付面试

面试的一大技巧就是引导面试官问你擅长的领域，面试中**操作系统**方面的问题出现的频率特别高，典型的『多进程与多线程的对比』、『同步和异步，阻塞与非阻塞』等。做出这个项目，至少能cover掉OS面试中操作系统问题很大的占比，让我们面试的把握更大。

#### 实践出真知

软件开发是一门动手学科，在实践过程中，你才能体会到『啊哈，灵机一动！』（来自《编程珠玑》）的感觉，避免学了忘，忘了学，学了还得忘的尴尬。


## 做了这个项目我能收获到什么？

- 多进程是怎么工作的
- 信号还怎么处理的
- 僵尸进程是什么东西，如何回收

# 设计目标

一个shell的雏形，不同技术分支的功能要能实现（内置命令、可执行文件、作业管理、重定向、管道）

## 实现的功能


-  能够执行内置命令 或 可执行文件

- 能够进行job管理

- 每个job有自己的信息

- 能够列出当前运行的所有job

    `jobs`

- 能够后台运行job（当然也能前台运行）

    `&`后缀

- 能够进行信号处理
- 能够回收所有的僵尸进程

    如果有的进程因为被信号中止而没有被回收，则需要打印出进程的信息

- 支持重定向

    需要先支持一个简单的echo

- 支持管道

# 设计思路及折衷


###  能够执行内置命令 或 可执行文件

通过分支进行执行，系统内部有的命令，直接调用功能。没有的，通过`exec*`函数进行执行。

### 能够进行job管理

这部分是本项目的难点

1. job id：PID/JID（%作为前缀）
2. job status：正在运行、结束（已终止、已停止）
3. job command：最好保存一下执行该job的命令，为后端debug做准备
4. signal handle：预先定义需要注意的信号（比如ctrl-c，ctrl-z）



#### 每个job有自己的信息

#### 能够列出当前运行的所有job

`jobs`

通过一个数组，管理多个进程，这个进程好像状态机一样，什么时候该变换状态

#### 能够后台运行job（当然也能前台运行）

`&`后缀

#### 能够进行信号处理

一个正在执行的进程是如何收到信号的？你理解这个并发的过程吗？多进程是怎么回事？


是否等子进程？如果children还在执行主进程是什么状态？这种情况称为孤儿（orphan）进程，通过重新分配给`init`进行管理，也就是为什么我们只需要打印一下就可以了。**这个场景是：子进程还在执行，但父进程被信号终止了。**

#### 能够回收所有的僵尸进程

如果有的进程因为被信号中止而没有被回收，则需要打印出进程的信息
回收僵尸进程通过`waitpid`

### 支持重定向


前置条件：需要先支持一个简单的ls -l（可执行程序）作为验证命令

简单来说就是将『标准输出』重定向到『某个文件描述符』，通过`dup2`

### 支持管道

知道底层os是怎么在管理**进程间通信**。
连续设置文件描述符，第一个fd为stdin，最后一个fd为stdout。


当目前为止，方案有没有想清楚？每个功能应该怎么设计有没有想清楚？

# 系统设计

当前系统主要的复杂度来自job管理，这个job需要维护自己的状态，**何时改变状态是一个非常需要注意的决策**

## 基本介绍

## 系统流程图及说明

![system_design](./readme/system_img.png)


## 与外部系统的接口
无

## 数据结构及说明

job的数据解构
上面列出了相关的功能，可以简单设计一个类：

```cpp
//伪代码
class job:
    //参数
    pid
    jid
    string cmd
    status //后面可改为枚举

    //获取基本信息
    print_job_info_by_pid()
    print_job_info_by_jid()

    //获取到job对象
    get_job_from_pid()
    get_job_from_jid()
    set_status_pid()
    set_status_jid()

    //列出所有的job
    list_total_jobs()

    //信号处理
    signal_handle_kill()
    signal_handle_stop()
    signal_handle_continue()
```

#### 重定向：

```py
def redirect(in, out):
```

#### 管道
1. 分解当前命令（'|'）
2. 遍历多个命令，第一个的输入时`STDIN`，最后一个的输入`STDOUT`
3. 中间进行迭代重定向

```py
# python pseudocode
def redirect(in, out, cmd):

in = STDIN

cmds = total_cmd.split('|')
for cmd in cmds:
    int current_fd
    if cmd is last_cmd:
        redirect(current_fd, STDOUT, cmd)

    redirect(in, current_fd, cmd)
    in = current_fd

```

### TDD

#### 基本的功能测试

```
# 基本的执行命令
ls -l # 可执行文件
sleep 100 # 内置命令
slepp 100 &

# 列出所有job信息
jobs

# 进行信号管理
ctrl-z
ctrl-c
bg PID # 继续在后台执行
fg PID # 继续在前台执行

# 进行重定向测试
ls -l > a_file

# 进行管道测试
ls -l | cat | head -n 1 > a_file

```

## 异常处理

注意写代码时先写happy-tree，也是有套路的
某些错误处理时，先标记上即可
关于字符串的部分，这里稍显复杂，与主题无关，所以目前不支持一些错误判定（基本的字符串处理还是有的，比如前后的white space）
